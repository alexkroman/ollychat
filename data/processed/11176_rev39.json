[
  {
    "name": "Total datapoints",
    "description": "How many [data samples](https://docs.victoriametrics.com/keyconcepts/#raw-samples) are in storage",
    "queries": [
      "sum(vm_rows)"
    ]
  },
  {
    "name": "Ingestion rate",
    "description": "Shows the datapoints ingestion rate, including replication factor.",
    "queries": [
      "sum(rate(vm_vminsert_metrics_read_total[30m])) "
    ]
  },
  {
    "name": "Read requests",
    "description": "Shows the rate of HTTP read requests.",
    "queries": [
      "sum(rate(vm_http_requests_total[30m]))"
    ]
  },
  {
    "name": "Available CPU",
    "description": "Total number of available CPUs for all VM components. ",
    "queries": [
      "sum(vm_available_cpu_cores)"
    ]
  },
  {
    "name": "Active series",
    "description": "Shows the number of [active time series](https://docs.victoriametrics.com/faq/#what-is-an-active-time-series) with new data points inserted during the last hour. High value may result in ingestion slowdown.",
    "queries": [
      "sum(max_over_time(vm_cache_entries[1h]))"
    ]
  },
  {
    "name": "Disk space usage",
    "description": "Total amount of used disk space",
    "queries": [
      "sum(vm_data_size_bytes)"
    ]
  },
  {
    "name": "Bytes per point",
    "description": "Average disk usage per datapoint.",
    "queries": [
      "sum(vm_data_size_bytes) / sum(vm_rows)"
    ]
  },
  {
    "name": "Available memory",
    "description": "Total size of available memory for all VM components.",
    "queries": [
      "sum(vm_available_memory_bytes)"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "sum(vm_app_version) by(job, short_version)"
    ]
  },
  {
    "name": "Uptime ($job)",
    "description": "",
    "queries": [
      "sum(min_over_time(up[30m])) by (job)"
    ]
  },
  {
    "name": "Datapoints ingestion rate ($instance)",
    "description": "How many [data samples](https://docs.victoriametrics.com/keyconcepts/#raw-samples) are inserted into cluster per second by protocol before the replication. Check vminsert metrics if there are any issues with ingestion.",
    "queries": [
      "sum(rate(vm_rows_inserted_total[30m])) by (type) > 0 "
    ]
  },
  {
    "name": "Requests rate ($instance)",
    "description": "* `*` - unsupported query path\n* `/write` - insert into VM\n* `/metrics` - query VM system metrics\n* `/query` - query instant values\n* `/query_range` - query over a range of time\n* `/series` - match a certain label set\n* `/label/{}/values` - query a list of label values (variables mostly)",
    "queries": [
      "sum(rate(vm_http_requests_total[30m])) by (path) > 0"
    ]
  },
  {
    "name": "Active time series ($instance)",
    "description": "Shows the number of [active time series](https://docs.victoriametrics.com/faq/#what-is-an-active-time-series) with new data points inserted during the last hour across all storage nodes. High value may result in ingestion slowdown and high memory usage.",
    "queries": [
      "sum(vm_cache_entries)"
    ]
  },
  {
    "name": "Query duration 0.99 quantile ($instance)",
    "description": "The less time it takes is better.\n* `*` - unsupported query path\n* `/write` - insert into VM\n* `/metrics` - query VM system metrics\n* `/query` - query instant values\n* `/query_range` - query over a range of time\n* `/series` - match a certain label set\n* `/label/{}/values` - query a list of label values (variables mostly)",
    "queries": [
      "max(vm_request_duration_seconds) by (path) > 0"
    ]
  },
  {
    "name": "Requests error rate ($instance)",
    "description": "* `*` - unsupported query path\n* `/write` - insert into VM\n* `/metrics` - query VM system metrics\n* `/query` - query instant values\n* `/query_range` - query over a range of time\n* `/series` - match a certain label set\n* `/label/{}/values` - query a list of label values (variables mostly)",
    "queries": [
      "sum(rate(vm_http_request_errors_total[30m])) by (job, path) > 0"
    ]
  },
  {
    "name": "Logging rate",
    "description": "Shows the rate of logging the messages by their level. Unexpected spike in rate is a good reason to check logs.",
    "queries": [
      "sum(rate(vm_log_messages_total[30m])) by (job, level) > 0"
    ]
  }
]