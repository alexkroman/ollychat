[
  {
    "name": "",
    "description": "Cluster Replication Health represents the availability of replica servers available to replace the primary in case of a failure.",
    "queries": [
      "max(cnpg_pg_replication_streaming_replicas - cnpg_pg_replication_is_wal_receiver_up)"
    ]
  },
  {
    "name": "",
    "description": "High lag indicates issue with replication. Network or storage interfaces may not have enough bandwidth to handle incoming traffic and replication at the same time.",
    "queries": [
      "max(cnpg_pg_replication_lag) + max(cnpg_pg_stat_replication_write_lag_seconds) + max(cnpg_pg_stat_replication_flush_lag_seconds) + max(cnpg_pg_stat_replication_replay_lag_seconds)",
      ""
    ]
  },
  {
    "name": "",
    "description": "Low disk space or low inode count will result in data loss.",
    "queries": [
      "max((max(max by(persistentvolumeclaim) (1 - kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes))) OR (max by(persistentvolumeclaim) (kubelet_volume_stats_inodes_used / kubelet_volume_stats_inodes)))"
    ]
  },
  {
    "name": "Last failover",
    "description": "",
    "queries": [
      "max(cnpg_pg_postmaster_start_time)*1000"
    ]
  },
  {
    "name": "TPS",
    "description": "",
    "queries": [
      "sum(rate(cnpg_pg_stat_database_xact_commit[$__interval])) + sum(rate(cnpg_pg_stat_database_xact_rollback[$__interval]))"
    ]
  },
  {
    "name": "CPU Utilisation",
    "description": "CPU Utilisation from Requests",
    "queries": [
      "sum(node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate) / sum(kube_pod_container_resource_requests)"
    ]
  },
  {
    "name": "Memory Utilisation",
    "description": "Memory Utilisation from Requests",
    "queries": [
      "sum(container_memory_working_set_bytes) / sum(max by(pod) (kube_pod_container_resource_requests))"
    ]
  },
  {
    "name": "Replication Lag",
    "description": "",
    "queries": [
      "max(cnpg_pg_replication_lag)"
    ]
  },
  {
    "name": "Write Lag",
    "description": "",
    "queries": [
      "max(cnpg_pg_stat_replication_write_lag_seconds)"
    ]
  },
  {
    "name": "Volume Space Usage",
    "description": "",
    "queries": [
      "max(max by(persistentvolumeclaim) (1 - kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes))",
      "max(max by(persistentvolumeclaim) (1 - kubelet_volume_stats_available_bytes)-wal\"} / kubelet_volume_stats_capacity_bytes)-wal\"}))",
      "max(\n    sum by (namespace,persistentvolumeclaim) (kubelet_volume_stats_used_bytes)-tbs.*\"}) \n    /\n    sum by (namespace,persistentvolumeclaim) (kubelet_volume_stats_capacity_bytes)-tbs.*\"}) \n    *\n    on(namespace, persistentvolumeclaim) group_left(volume)\n    kube_pod_spec_volumes_persistentvolumeclaims_info\n)"
    ]
  },
  {
    "name": "Last Base Backup",
    "description": "Elapsed time since the last successful base backup.",
    "queries": [
      "-(time() - max(cnpg_collector_last_available_backup_timestamp))"
    ]
  },
  {
    "name": "",
    "description": "High resource usage (CPU, Memory, DB Connections)",
    "queries": [
      "(sum(node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate) / sum(kube_pod_container_resource_requests))",
      "(sum(container_memory_working_set_bytes) / sum(max by(pod) (kube_pod_container_resource_requests)))",
      " (max(sum by (pod) (cnpg_backends_total) / sum by (pod) (cnpg_pg_settings_setting)))"
    ]
  },
  {
    "name": "Last archived WAL",
    "description": "Computes the time since the last known WAL archival in the primary.\nWe ensure to ignore the metric in the replicas by using (1 - cnpg_pg_replication_in_recovery ) as a multiplicative factor. It will be 0 for replicas, 1 for the primary.",
    "queries": [
      "max((1 - cnpg_pg_replication_in_recovery) * (time() - timestamp(cnpg_pg_stat_archiver_seconds_since_last_archival) +\ncnpg_pg_stat_archiver_seconds_since_last_archival))"
    ]
  },
  {
    "name": "Version",
    "description": "",
    "queries": [
      "cnpg_collector_postgres_version"
    ]
  },
  {
    "name": "Flush Lag",
    "description": "",
    "queries": [
      "max(cnpg_pg_stat_replication_flush_lag_seconds)"
    ]
  },
  {
    "name": "Replay Lag",
    "description": "",
    "queries": [
      "max(cnpg_pg_stat_replication_replay_lag_seconds)"
    ]
  },
  {
    "name": "",
    "description": "Base Backups are considered healthy when there has been at least one base backup in the last 24 hours.",
    "queries": [
      "time() - max(cnpg_collector_last_available_backup_timestamp)"
    ]
  },
  {
    "name": "",
    "description": "Base Backups are considered healthy when there has been at least one base backup in the last 24 hours.",
    "queries": [
      "max((1 - cnpg_pg_replication_in_recovery) * (time() - timestamp(cnpg_pg_stat_archiver_seconds_since_last_archival) +\ncnpg_pg_stat_archiver_seconds_since_last_archival))"
    ]
  },
  {
    "name": "",
    "description": "Online if there is at least one ready operator pod",
    "queries": [
      "sum by (label_app_kubernetes_io_name) (kube_pod_status_ready * on (pod) group_left( label_app_kubernetes_io_name ) kube_pod_labels)"
    ]
  },
  {
    "name": "",
    "description": "The operator reconcile errors don't distinguish between database cluster or namespaces.",
    "queries": [
      "clamp_max(max(controller_runtime_reconcile_total), 1)",
      "clamp_max(max(controller_runtime_reconcile_total), 1)",
      "clamp_max(max(controller_runtime_reconcile_total), 1)",
      "clamp_max(max(controller_runtime_reconcile_total), 1)",
      ""
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "sum(node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate)"
    ]
  },
  {
    "name": "",
    "description": "Excluding cache",
    "queries": [
      "sum(container_memory_working_set_bytes)"
    ]
  },
  {
    "name": "Database Size",
    "description": "",
    "queries": [
      "cnpg_pg_database_size_bytes"
    ]
  },
  {
    "name": "First Recoverability Point",
    "description": "",
    "queries": [
      "max(cnpg_collector_first_recoverability_point)*1000"
    ]
  },
  {
    "name": "Instance",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Status",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Clustering / replicas",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Zone",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Connections",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Max Connections",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Wraparound",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Started",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "Version",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "kube_pod_container_status_ready"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "min(kube_pod_container_status_ready)"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "1 - cnpg_pg_replication_in_recovery + cnpg_pg_replication_is_wal_receiver_up"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "cnpg_pg_replication_streaming_replicas"
    ]
  },
  {
    "name": "",
    "description": "This metric depends on exporting the: `topology.kubernetes.io/zone` label through kube-state-metrics (not enabled by default). Can be added by changing its configuration with:\n\n```yaml\nmetricLabelsAllowlist:\n  - nodes=[topology.kubernetes.io/zone]\n```",
    "queries": [
      "kube_pod_info * on(node,instance) group_left(label_topology_kubernetes_io_zone) kube_node_labels"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "sum by (pod) (cnpg_backends_total)"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "100 * sum by (pod) (cnpg_backends_total) / sum by (pod) (cnpg_pg_settings_setting)"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "max by (pod) (cnpg_pg_database_xid_age)"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "cnpg_pg_postmaster_start_time*1000"
    ]
  },
  {
    "name": "",
    "description": "",
    "queries": [
      "cnpg_collector_postgres_version"
    ]
  },
  {
    "name": "CPU Usage",
    "description": "",
    "queries": [
      "sum(node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate) by (pod)"
    ]
  },
  {
    "name": "Memory Usage (w/o cache)",
    "description": "",
    "queries": [
      "sum(container_memory_working_set_bytes) by (pod)"
    ]
  },
  {
    "name": "Session States",
    "description": "",
    "queries": [
      "sum(cnpg_backends_total) by (pod)",
      "sum(cnpg_backends_total) by (state, pod)"
    ]
  },
  {
    "name": "Transactions [5m]",
    "description": "",
    "queries": [
      "sum(rate(cnpg_pg_stat_database_xact_commit[5m])) by (pod)",
      "sum(rate(cnpg_pg_stat_database_xact_rollback[5m])) by (pod)"
    ]
  },
  {
    "name": "Longest Transaction",
    "description": "",
    "queries": [
      "max by (pod) (cnpg_backends_max_tx_duration_seconds)"
    ]
  },
  {
    "name": "Deadlocks [5m]",
    "description": "",
    "queries": [
      "rate(cnpg_pg_stat_database_deadlocks[5m])"
    ]
  },
  {
    "name": "Blocked Queries",
    "description": "",
    "queries": [
      "cnpg_backends_waiting_total"
    ]
  }
]